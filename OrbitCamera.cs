using UnityEngine;

/*
 * Сценарий вращения нацеленной на объект камеры вокруг объекта
 */

public class OrbitCamera : MonoBehaviour
{
    /*Код должен знать, вокруг какого объекта будет вращаться камера, 
     * поэтому данная переменная была сериализована, 
     * чтобы появиться в редакторе Unity и дать возможность связать с ней объект player.*/

    [SerializeField] private Transform target; //target - цель

    /* Следующая пара переменных связана с углами поворота и используется тем же способом, 
     * что и в коде управления камерой в главе 2.*/

    public float rotSpeed = 1.5f;
    private float _rotY;
    private Vector3 _offset;

    /* Еще код содержит объявление переменной _offset; 
     * в методе Start() ей присваивается разница в положении камеры и целевого объекта. 
     * Она позволяет в процессе выполнения кода сценария сохранять относительное положение камеры. 
     * Другими словами, камера все время остается на одном и том же расстоянии от целевого объекта, 
     * в какую бы сторону она ни поворачивалась.*/

    void Start()
    {
        _rotY = transform.eulerAngles.y;
        _offset = target.position - transform.position;
    }

    /* Остальная часть кода помещена в метод LateUpdate().
     * Во-первых, код увеличивает значение поворота в зависимости от элементов управления вводом. 
     * У нас есть элементы двух типов: клавиши с горизонтальными стрелками и 
     * горизонтальные перемещения указателя мыши, — 
     * поэтому для переключения между ними используется условный оператор.   
     * Независимая проверка двух вариантов ввода позволяет в каждом случае задавать собственную 
     * скорость вращения.
     * 
     *Во-вторых, код задает положение камеры на основе положения целевого объекта и угла поворота. 
     *Скорее всего, самый непонятный фрагмент кода — это строка transform.position, 
     *содержащая математические вычисления, с которыми вы пока не сталкивались. 
     *Умножение вектора position на кватернион (обратите внимание, 
     *что угол поворота преобразован в кватернион методом Quaternion.Euler) дает новое положение, 
     *смещенное в соответствии с углом поворота. 
     *Этот новый вектор положения затем прибавляется к смещению от положения персонажа, 
     *что дает нам положение камеры.
     */

    void LateUpdate()
    {
        //Код проверяет, нажимаются ли клавиши со стрелками
        float horInput = Input.GetAxis("Horizontal");
        //при положительном результате проверки применяется этот тип ввода
        if (horInput != 0)
        {
            _rotY += horInput * rotSpeed;
        }
        //в противном случае проверяется указатель мыши.
        else
        {
            _rotY += Input.GetAxis("Mouse X") * rotSpeed * 3;
        }

        //Возвращает поворот, который поворачивает на _rotY градусов вокруг оси Y
        Quaternion rotation = Quaternion.Euler(0, _rotY, 0);
        transform.position = target.position - (rotation * _offset);

        /*Метод LookAt(), направляющий камеру на целевой объект;
        * он предназначен для нацеливания одного объекта (не обязательно камеры) на другой.
        * То есть без заключительной строки с методом LookAt камера будет летать вокруг персонажа,
        * при этом смотря в разные стороны.*/
        transform.LookAt(target);
    }
}


